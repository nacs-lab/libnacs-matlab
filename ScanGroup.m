%% Copyright (c) 2018-2018, Yichao Yu <yyc1992@gmail.com>
%
% This library is free software; you can redistribute it and/or
% modify it under the terms of the GNU Lesser General Public
% License as published by the Free Software Foundation; either
% version 3.0 of the License, or (at your option) any later version.
% This library is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
% Lesser General Public License for more details.
% You should have received a copy of the GNU Lesser General Public
% License along with this library.

%%
% Terminology:
% * Parameter: a nested struct that will be passed to `ExpSeq` as the context of a sequence.
% * Scan: a n-dimensional matrix of parameters to iterate over with sequences.
%     This is used to generate a list of parameters.
%     A scan may contain some fixed parameters and some variable parameters.
%     Represented by `ScanParam`.
% * Group: a (orderred) set of scans. Represented by `ScanGroup`.
% * Fallback (parameter/scan):
%     This contains the same information as a scan
%     (and is also represented by `ScanParam`)
%     but it does not correspond to any real sequence.
%     This contains the default fallback parameters for the real scans when the scan
%     does not have any value for a specific field.
% * Base index:
%     This is the index of the scan that is used as fallback for this scan.
%     If this is 0, the default one for the group is used.
% * Run parameter:
%     Parameters for the sequence runner rather than the sequences.
%     There can be only one per group.

%%
% This class represents a group of scans. Supported API:
% For sequence building:
% * grp() / grp() = ...:
%   grp(n) / grp(n) = ...:
%     Access the group's fallback parameter (`grp()`) or
%     the parameter for the n-th scan (`grp(n)`).
%
%     Mutation to the fallback parameter will affect the fallback values of
%     **ALL** scans in this `ScanGroup` including future ones.
%
%     Read access returns a `ScanParam`.
%     Write access constructs a `ScanParam` to **replace** the existing one.
%     The RHS must be another `ScanParam` from the same `ScanGroup` or a `struct`.
%
%     For `ScanParam` RHS, everything is copied. Fallback values are not applied.
%     If the LHS is `grp()`, base index of the RHS is ignored (otherwise, it is copied).
%     For `struct` RHS, all fields are treated as non-scanning parameters.
%     Non-string array field will cause an error.
%     This (`struct` RHS) will also clear the scan and set the base index to `0` (default)
%     (base index ignored when LHS is `grp()`).
%
% * [grp1 grp2 ...] / [grp1, grp2, ...] / horzcat(grp1, grp2, ...):
%     Create a new `ScanGroup` that runs the individual all input scans
%     in the order they are listed.
%     The new group will **NOT** be affected if the inputs are mutated later.
%     The scans with the default base (0) will all have their respected
%     fallback parameters merged into them.
%     Scans with non-default base will have their base index updated
%     to that of their fallback in the new group.
%     The new group size (sequence count) will be the sum of that of the input
%     groups and the order of the scans/sequences will be maintained.
%     The run parameters will be the same as that of the first one.
%
% * setbase(grp, scan, base) / grp.setbase(scan, base):
%     Set the base index of the `scan` to `base`. A `0` `base` means the default base.
%     Throws an error if this would create a loop.
%
%
% For sequence running/saving/loading:
% * groupsize(grp) / grp.groupsize():
%     Number of scans in the group. (Each scan is a N-dimensional matrix)
%
% * scansize(grp, idx) / grp.scansize(idx):
%     Number of sequences in the specific (N-dimensional) scan.
%
% * nseq(grp) / grp.nseq():
%     Number of sequences in the group. This is the sum of `scansize` over all scans.
%
% * getseq(grp, n) / grp.getseq(n):
%     Get the n-th sequence parameter.
%
% * dump(grp) / grp.dump():
%     Return a low level MATLAB data structure that can be saved without
%     refering to any classes related to the scan.
%     This can be later loaded to create an identical scan.
%     If there are significant change on the representation of the scan,
%     the new version is expected to load and convert
%     the result generated by an older version without error.
%
% * ScanGroup.load(obj):
%     This is the reverse of `dump`. Returns a `ScanGroup` that is identical to the
%     one that generates the representation with `dump`.
%
%
% For both:
% * runp(grp) / grp.runp():
%     Run parameters. (parameters for RunSeq/RunScanSeq etc)
%     The returned object is a `DynProps` and can be mutated.
%

%% WARNING!!!:
% Do **NOT** save this (or any) class to `mat` files.
% Saving class in mat files makes it almost (completely?) impossible
% to make major changes while keeping backward compatibility without
% renaming the class.
%
% Instead, one should store the necessary information as basic matlab types
% and allow convert from/to between the runtime format and the saving format.
% Ideally, this information should also be versioned so that future improvements
% can be added without breaking the loading of the old code.
classdef ScanGroup < handle
    properties(Access=?ScanParam)
        %% we don't use class here since
        % 1. it's annoy to use for simple stuff in MATLAB.
        % 2. it's harder to save (which I guess is also kind of annoy...)
        %
        % Structure:
        % * scans::array of Scan
        % * Scan: struct
        %     baseidx::integer (where to find the missing values for this group)
        %         A base index of `0` means that the base group is the toplevel base group.
        %     params::struct (simple structures holding the fixed parameters)
        %     vars::array of Scan1D
        %         Each element of the Scan1D array represent a scan dimension.
        %         The whole scan represent a rectangle N-dimension matrix.
        %         Different variables parameters are not allowed to have the same field.
        %         If this is empty, the group represent a single sequence.
        % * Scan1D: struct
        %     size::integer
        %         The size of the 1D scan. Must be greater than 1, all the parameters in the
        %         scan must have the same length.
        %     params::struct
        %         Each array members of the struct represents a list of parameter to scan.
        scans = struct([]);
        % * base::Scan
        %     This is the fallback parameter accessible by indexing without index, i.e. `grp()`.
        %     See above for the format of `Scan`.
        base = struct();
        runparam;
        % whether there's any write to the scan or fallback parameter since the last cache.
        scandirty = boolean([]);
        % cache of the full scan after combining with the base scan.
        scanscache = struct([]);
    end
    methods
        function self=ScanGroup()
            self.runparam = DynProps();
        end
        function res=runp(self)
            res = self.runparam;
        end
        function obj=dump(self)
            obj.version = 1;
            obj.scans = self.scans;
            obj.base = self.base;
            obj.runparam = self.runparam();
        end
        function seq=getseq(self, n)
            % TODO
        end
        function res=nseq(self)
            res = 0;
            for i=1:groupsize(self)
                res = res + scansize(self, i);
            end
        end
        function res=scansize(self, idx)
            % TODO
        end
        function res=groupsize(self)
            res = length(self.scans);
        end
        function setbase(self, grp, base)
            if ~(base >= 0 && isscalar(base) && isinteger(base))
                error('Base index must be non-negative integer.');
            end
            if self.getbaseidx(grp) == base
                return;
            end
            if base == 0
                self.scans(grp).baseidx = base;
                self.scandirty(grp) = true;
                return;
            end
            visited = false(length(self.scans), 1);
            visited(grp) = true;
            while true
                if visited(base)
                    error('Base index loop detected.');
                end
                visited(base) = true;
                base = self.getbaseidx(base);
                if base == 0
                    break;
                end
            end
            self.scans(grp).baseidx = base;
            self.scandirty(grp) = true;
        end
        function horzcat(self, varargin)
            % TODO
        end

        function varargout = subsref(self, S)
            % This handles the `grp([n]) ...` syntax.
            % We support chained operation so this needs to forward
            % the trailing index to the next handler by calling `subsref` directly.
            nS = length(S);
            if nS >= 1 && strcmp(S(1).type, '()')
                if isempty(S(1).subs)
                    % grp(): Fallback
                    idx = 0;
                elseif length(S(1).subs) == 1
                    % grp(n): Real scan
                    idx = S(1).subs{1};
                    if ~(idx > 0)
                        % Don't allow implicitly addressing the fallback with `0`
                        % Also use the negative check to handle wierd thing like NaN...
                        error('Scan index must be positive');
                    end
                else
                    error('Too many scan index');
                end
                grp = ScanParam(self, idx);
                if nS > 1
                    [varargout{1:nargout}] = subsref(grp, S{2:end});
                else
                    % At most one return value in this branch.
                    % Throw and error if we got more than that.
                    nargoutchk(0, 1);
                    if nargout ~= 0
                        varargout{1} = grp;
                    end
                end
                return;
            end
            [varargout{1:nargout}] = builtin('subsref', self, S);
        end
        function A = subsasgn(self, S, B)
            % This handles the `grp([n]) ... = ...` syntax,
            % including both direct assignment `grp([n]) = ...`
            % and assignment to the `ScanParam` object in a chained operation,
            % i.e. `grp([n]). ... = ...`.
            % Therefore, if there's more than one index,
            % we need to pass those on to `ScanParam`.
            nS = length(S);
            if nS >= 1 && strcmp(S(1).type, '()')
                if isempty(S(1).subs)
                    % grp(): Fallback
                    idx = 0;
                elseif length(S(1).subs) == 1
                    % grp(n): Real scan
                    idx = S(1).subs{1};
                    if ~(idx > 0)
                        % Don't allow implicitly address fallback with 0.
                        error('Scan index must be positive');
                    end
                else
                    error('Too many scan index');
                end
                A = self;
                if nS > 1
                    % Assignment to the `ScanParam`, pass that on.
                    grp = ScanParam(self, idx);
                    grp = subsasgn(grp, S{2:end}, B);
                    return;
                end
                if isa(B, 'ScanParam')
                    if B.group ~= self
                        error('Cannot assign scan from a different group.');
                    end
                    if B.idx == idx
                        % no-op
                        return;
                    end
                    if B.idx == 0
                        rgrp = self.base;
                        rbase = 0; % base index
                    else
                        rgrp = self.scans(B.idx);
                        rbase = self.getbaseidx(B.idx); % base index
                    end
                    if idx == 0
                        if isfield(rgrp, 'params')
                            self.base.params = rgrp.params;
                        else
                            self.base.params = struct();
                        end
                        if isfield(rgrp, 'vars')
                            self.base.vars = rgrp.vars;
                        else
                            self.base.vars = struct([]);
                        end
                        self.scandirty(:) = true;
                    else
                        % Call the setter function to check for loop.
                        setbase(self, idx, rbase);
                        if isfield(rgrp, 'params')
                            self.scans(idx).params = rgrp.params;
                        else
                            self.scans(idx).params = struct();
                        end
                        if isfield(rgrp, 'vars')
                            self.scans(idx).vars = rgrp.vars;
                        else
                            self.scans(idx).vars = struct([]);
                        end
                        self.scandirty(idx) = true;
                    end
                    return;
                elseif ScanGroup.hasarray(B)
                    error('Mixing fixed and variable parameters not allowed.');
                end
                if idx == 0
                    self.base.params = B;
                    self.base.vars = struct([]);
                    self.scandirty(:) = true;
                else
                    self.scans(idx).params = B;
                    self.scans(idx).vars = struct([]);
                    self.scans(idx).baseidx = 0;
                    self.scandirty(idx) = true;
                end
                return;
            end
            A = builtin('subsasgn', self, S, B);
        end
    end
    methods(Access=?ScanParam)
        function base=getbaseidx(self, idx)
            scan = self.scans(grp);
            if ~isfield(scan, 'baseidx')
                base = 0;
            else
                base = scan.baseidx;
            end
        end
        function validate(self)
            % TODO
        end
    end
    methods(Static, Access=?ScanParam)
        %% Check if the object is an array for scan parameter.
        % Rules are:
        % 1. All scalar are not array
        % 2. Cell arrays are always array
        % 3. char array alone the horizontal direction does not count as array
        % 4. All other arrays are array
        function res = isarray(obj)
            if iscell(obj)
                res = true;
            elseif ischar(obj)
                res = length(obj) ~= size(obj, 2);
            else
                res = ~isscalar(obj);
            end
        end
        %% Recursively check if any of the struct fields are array.
        function res = hasarray(obj)
            res = isarray(obj);
            if res
                return;
            elseif ~isstruct(obj)
                return;
            end
            for name=fieldnames(obj)
                if isarray(obj.(name{:}))
                    res = true;
                    return;
                end
            end
        end
    end
    methods(Static)
        function self=load(obj)
            self = ScanGroup();
            if obj.version ~= 1
                error('Wrong object version: %d', obj.version);
            end
            self.scans = obj.scans;
            self.base = obj.base;
            self.runparam(obj.runparam);
            self.validate();
        end
    end
end
